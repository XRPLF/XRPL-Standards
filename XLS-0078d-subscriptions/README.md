<pre>
xls: 0078d
title: XLS-78d Subscriptions
description: A subscription mechanism for recurring payments on the XRP Ledger
author: Chris Dangerfield <xrpl365@gmail.com>, Denis Angell <dangell@transia.co>
status: Draft
category: Community
created: 2021-01-01
</pre>

# Subscriptions

## Abstract

This proposal introduces a subscription (re-occurring payments) mechanism to the XRP Ledger (XRPL), enabling functionality similar to direct debits, thus removing the need for users to sign a transaction for each payment. The account owner will define values that are used to protect against abuse.

## Motivation and Rationale

Currently, payments on the XRP Ledger require the sender to initiate and sign each transaction. With the introduction of off-chain solutions like Xaman API, the concept of pull payments emerged, where a transaction can be generated by the destination address and signed by the sender. However, this method still requires the user to authorize each transaction individually, which is not practical for services requiring regular, recurring payments, ie: subscriptions.

This proposal addresses this limitation by introducing a subscription feature that allows for pre-authorized recurring payments, improving the user experience and enabling a broader range of services on the XRP Ledger.

The proposed subscription model is designed to balance user convenience with security. By allowing pre-authorized payments within defined parameters, the system reduces the need for frequent user interaction while maintaining control over the amounts and frequency of payments. This approach also allows businesses to automate billing processes, improving service delivery while ensuring that users retain oversight and control of their recurring payments. The subscription feature enhances the versatility of the XRP Ledger, making it more accommodating for services that rely on automated, regular payments.

This proposal will support both payments in XRP and issued assets.

## Amendment

This feature enables account owners to authorize automated payments with predefined parameters such as amount, frequency, and destination, reducing the need for manual transaction signing each time.

The amendment adds the following:

- A new ledger entry: `Subscription`
- A new transaction type: `SubscriptionSet`
- A new transaction type: `SubscriptionCancel`
- A new transaction type: `SubscriptionClaim`

### **New Ledger Entry: `Subscription`**

The `Subscription` ledger entry is a new on-ledger object that stores the details of the subscription, including the destination address, the maximum allowable amount, the frequency of the payments, and the start time of the subscription.

**Fields:**

| Field             | Type      | Required | Description                                                                                                                      |
| ----------------- | --------- | -------- | -------------------------------------------------------------------------------------------------------------------------------- |
| sfAccount         | AccountID | ✔️       | The account that owns the subscription.                                                                                          |
| sfDestination     | AccountID | ✔️       | The account authorized to receive the subscription payments.                                                                     |
| sfDestinationTag  | Number    |          | Support for subscription payment categorization by the Destination.                                                              |
| sfAmount          | Amount    | ✔️       | The subscription amount (max) that can be withdrawn during each time period.                                                     |
| sfFrequency       | UInt64    | ✔️       | The time period (in seconds) between consecutive payments (e.g., 2592000 for monthly).                                           |
| sfNextPaymentTime | UInt32    | ✔️       | The next time (Ripple epoch time) the payment can be claimed. This field is automatically updated after each successful payment. |
| sfExpiration      | UInt32    |          | The time (Ripple epoch time) of the last payment. Allows for optional fixed period subscriptions.                                |

**Example `Subscription` object:**

```
{
  "LedgerEntryType": "Subscription",
  "Account": "r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59",
  "Destination": "rLdCa1mLK5R5Am25ArfXFmqgNwjZgnfy91",
  "DestinationTag": 10, // Bob is customer number 10
  "Amount": "100000000", // 100 XRP
  "Frequency": 2592000, // 30 days in seconds
  "NextPaymentTime": 711232800, // (example epoch time for next payment)
  "Expiration": 721600800 // (example epoch time for final payment)
}
```

We compute the `Subscription` object ID, a.k.a., SubscriptionID as the SHA-512Half of the following values, concatenated in order:

- The Subscription space key (0x00??)
- The Account ID
- The Destination ID
- The Txn Sequence

### **New Transaction Type: `SubscriptionSet`**

The `SubscriptionSet` transaction is used to create a new subscription. The account owner specifies the destination, amount, frequency, and optionally the start time.

**Fields:**

| Field             | Type      | Required | Description                                                                                              |
| ----------------- | --------- | -------- | -------------------------------------------------------------------------------------------------------- |
| sfTransactionType | String    | ✔️       | The type of transaction:`SubscriptionSet`.                                                               |
| sfAccount         | AccountID | ✔️       | The account that is creating the subscription.                                                           |
| sfDestination     | AccountID |          | The account authorized to receive the subscription payments.                                             |
| sfDestinationTag  | Number    |          | A destination tag to be associated with the subscription payment.                                        |
| sfAmount          | Amount    | ✔️       | The subscription amount (max) that can be withdrawn during each time period.                             |
| sfFrequency       | UInt64    |          | The time period (in seconds) between consecutive payments.                                               |
| sfStartTime       | UInt32    |          | (Optional) The time (Ripple epoch time) when the subscription starts. If not set, it starts immediately. |
| sfExpiration      | UInt32    |          | (Optional) The time (Ripple epoch time) when the subscription ends.                                      |
| sfSubscriptionID  |           |          | (Optional) Used for updating a subscription.                                                             |

**Example `SubscriptionSet` Transaction (Create):**

```
{
  "TransactionType": "SubscriptionSet",
  "Account": "r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59",
  "Destination": "rLdCa1mLK5R5Am25ArfXFmqgNwjZgnfy91",
  "DestinationTag": 10, // Bob is customer number 10
  "Amount": "100000000", // 100 XRP
  "Frequency": 2592000, // 30 days in seconds
  "StartTime": 711232800, // (example epoch time for start time)
  "Expiration": 721600800 // (example epoch time for final payment)
}
```

**Example `SubscriptionSet` Transaction (Update):**

```
{
  "TransactionType": "SubscriptionSet",
  "Account": "r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59",
  "Amount": "100000000", // 100 XRP
  "Expiration": 724192800, // (example epoch time for final payment increased by one frequency period)
  "SubscriptionID": "E8A6F9B99B041DF5C932DF8DA29B2A84B42D4D4F0F4A08931D76D62F42E1F1B9"
}
```

#### **Failure Conditions** (Create)

- `Destination` is the same as `Account`.
- `Amount` is invalid OR <= 0.
- `Frequency` <= SYSTEM_MINIMUM (global value defining the minimum frequency: eg 1 hour or 1 day).
- `Subscription` ledger entry exists.
- `Account` does not have a valid Trustline (Limit, Frozen, Auth, Rippling).
- `StartTime` is less than the current time.
- `Expiration` is less than the current time.
- `Expiration` is less than the `StartTime`.
- `Expiration` is less than the `NextPaymentTime`.

#### State Changes (Create)

- Creates the `Subscription` ledger entry, initializing all the fields.
- If the `StartTime` field is included then the `NextPaymentTime` is the `StartTime`.
- If the `StartTime` field is not included then the `NextPaymentTime` is the current ledger time.

#### **Failure Conditions** (Update)

- Subscription Entry `Account` is not the same as the txn `Account`.
- `Amount` is invalid OR <= 0.
- `Subscription` ledger entry does not exists.
- `Account` does not have a valid Trustline (Limit, Frozen, Auth, Rippling).
- `Expiration` is less than the current time.
- `Expiration` is less than the `StartTime`.
- `Expiration` is less than the `NextPaymentTime`.
- `SubscriptionID` submitted and `Amount` not present or optional `Expiration` not present.

#### State Changes (Update)

- Updates the `Amount` and `Expiration`.

### **New Transaction Type: `SubscriptionCancel`**

The `SubscriptionCancel` transaction is used to cancel an existing subscription. The transaction must be signed by the account that created the subscription.

**Fields:**

| Field             | Type      | Required | Description                                               |
| ----------------- | --------- | -------- | --------------------------------------------------------- |
| sfTransactionType | String    | ✔️       | The type of transaction:`SubscriptionCancel`.             |
| sfAccount         | AccountID | ✔️       | The account that created the subscription.                |
| sfSubscriptionID  | Hash256   | ✔️       | The unique identifier of the subscription to be canceled. |

**Example `SubscriptionCancel` Transaction:**

```
{
  "TransactionType": "SubscriptionCancel",
  "Account": "r9cZA1mLK5R5Am25ArfXFmqgNwjZgnfk59",
  "SubscriptionID": "E8A6F9B99B041DF5C932DF8DA29B2A84B42D4D4F0F4A08931D76D62F42E1F1B9"
}
```

#### **Failure Conditions**

- `SubscriptionID` does not exist.
- `Account` is not the owner of the `Subscription` OR the `Destination` on the `Subscription`.

#### **State Changes**

- Removes the `Subscription` ledger entry associated with the given `SubscriptionID`.

### **New Transaction Type: `SubscriptionClaim`**

The `SubscriptionClaim` transaction is used by the destination (beneficiary) to pull the funds from the subscriber’s account according to the predefined rules.

**Fields:**

| Field             | Type      | Required | Description                                                                         |
| ----------------- | --------- | -------- | ----------------------------------------------------------------------------------- |
| sfTransactionType | String    | ✔️       | The type of transaction:`SubscriptionClaim`.                                        |
| sfAccount         | AccountID | ✔️       | The account authorized to receive the subscription payment.                         |
| sfSubscriptionID  | Hash256   | ✔️       | The unique identifier of the subscription being claimed.                            |
| sfAmount          | Amount    | ✔️       | The amount being pulled, which must be less than or equal to the authorized amount. |

**Example `SubscriptionClaim` Transaction with XRP:**

```
{
  "TransactionType": "SubscriptionClaim",
  "Account": "rLdCa1mLK5R5Am25ArfXFmqgNwjZgnfy91",
  "SubscriptionID": "E8A6F9B99B041DF5C932DF8DA29B2A84B42D4D4F0F4A08931D76D62F42E1F1B9",
  "Amount": "100000000" // 100 XRP
}
```

**Example `SubscriptionClaim` Transaction with issued asset:**

```
{
  "TransactionType": "SubscriptionClaim",
  "Account": "rLdCa1mLK5R5Am25ArfXFmqgNwjZgnfy91",
  "SubscriptionID": "E8A6F9B99B041DF5C932DF8DA29B2A84B42D4D4F0F4A08931D76D62F42E1F1B9",
  "Amount": {
    "currency": "USD",
    "value": "20",
    "issuer": "rUSDIssuerWKDv6jmDy1pUykJzF3wq" // Example issuer
  }
}
```

#### **Failure Conditions**

- Subscription ledger entry does not exist for SubscriptionID.
- `Account` is not the destination (beneficiary) specified in the `Subscription` OR the destination of the `Subscription`.
- `Amount` is < 0.
- If `Amount` is IOU and IOU is a "bad" currency.
- `Amount` (type) does not equal `Subscription` `Amount` (type).
- `Amount` exceeds the authorized amount in the subscription.
- `Account` has insufficient funds
- `Account` does not have a valid Trustline (Limit, Frozen, Auth, Rippling)
- `Destination` does not have a valid Trustline (Limit, Frozen, Auth, Rippling) (Optional)
- `Destination` does not have enough XRP to cover creation of Trustline (Optional)
- Current time is before `NextPaymentTime`.

#### **State Changes**

- Deducts the specified `Amount` from the subscriber’s account.
- Updates `NextPaymentTime` in the `Subscription` ledger entry to the `NextPaymentTime` plus the `Frequency`.
- Credit the specified `Amount` to the destination account.
- Create `Destination` Trustline (Optional)
- Removes the `Subscription` ledger object where time > `Expiration`.

## Zero Value Claims

In this proposal a zero value claim is not a failure condition; no value is transferred but the `NextPaymentTime` field is updated.

## Transaction Fees & Reserves

It is assumed that all transactions related to subscriptions, including `SubscriptionSet`, `SubscriptionCancel`, and `SubscriptionClaim`, should incur standard transaction fees inline with regular payments.

The `Subscription` ledger entry will require an increase in the account's reserve by the standard amount applicable to other ledger objects on the XRP Ledger. This ensures that accounts cannot create an excessive number of subscriptions without maintaining sufficient reserves.

## **Key Points to Understand**

- **Transaction Claim:** The `NextPaymentTime` updates upon success, meaning only one pull payment can be successfully claimed within the period.
- **Time Management:** The `NextPaymentTime` field in the `Subscription` ledger entry ensures that payments cannot be claimed more frequently than specified by the `Frequency`.
- **Security:** Since the subscription creation requires explicit user authorization, only an amount up-to the pre-approved value can be withdrawn.

## Basic Flow Scenarios

#### **User Onboarding**

- The user signs up for a service.
- The service generates a subscription request with details like amount and frequency.
- The user reviews and signs the subscription, creating it on the XRPL.

#### **Service Pulls Payment**

- The service claims a payment immediately if the start date is set to "now" or after the specified start date has passed.
- Reoccurring payments are pulled as per the subscription details.

#### **Payment Failure**

- If a payment fails due to insufficient funds, the service notifies the user and retries after eg: 7 days.
- Upon successful retry, the payment process continues as normal.

#### **Fee Increase**

- The service increases its charge and notifies the user.
- The user is prompted to update the subscription amount with a `SubscriptionSet` transaction.

#### **Cancellation**

- The user can cancel the subscription at any time, effectively ending the service.
- Ideally, the user informs the service before cancelling, but this is not mandatory.
- The service can also cancel the subscription at anytime.

## Backward Compatibility

The introduction of subscription transactions is backward-compatible as it does not alter existing transaction types or the current operation of the XRPL. Users who do not opt into the subscription system will experience no changes. Additionally, the subscription settings will be added as a new ledger object.

## Conclusion

The proposed subscription feature introduces a much-needed capability to the XRPL, enabling automated recurring payments in a secure and user-friendly manner. By allowing users to pre-authorize transactions within defined parameters, the system reduces the friction associated with recurring payments, enabling a broader range of services to be supported on the XRP Ledger.

## FAQ

### A.1 What is the logic/decision making behind only allowing one pull payment?

The primary reason for limiting pull payments to one per subscription period is to simplify the implementation and management of the subscription system. Allowing multiple pull payments within a single period would require maintaining or checking a running balance of how much has already been pulled within that period. This adds significant complexity to the system, as it would need to track multiple transactions, ensure they don't exceed the authorized limit, and adjust the remaining balance accordingly after each pull.

By restricting it to a single transaction per period:

1. **Prevention of Account Spamming**: By limiting to one payment per period, the system prevents scenarios where a service might attempt to pull small amounts frequently (e.g., 1 XRP daily from a 30 XRP monthly limit). This would result in unnecessary transaction noise, potentially overwhelming the user's transaction history and creating confusion.
2. **Simplified Implementation**: The system avoids the need to continuously track and update the remaining balance within a subscription period.
3. **Efficient Resource Management**: While the primary focus is on simplifying implementation, restricting to one transaction per period also reduces the load on the XRPL. It avoids unnecessary multiple transactions that could otherwise increase processing requirements without providing additional value, ensuring smoother ledger operations. In scenarios where a service wanted to bill weekly rather than monthly, the subscription should just be setup with a frequency of weekly.
4. **Practical Usage:** In most cases the service would pull the max amount from the account each month; but there are good reasons why a service may wish to pull less than the max amount and as long as the service fully understands the limitation I see no reason to over-complicate the design.

### A.2 Why can a payment be pulled that is less than the authorized amount?

The subscription model allows for flexibility in the amount that can be pulled during each payment cycle, provided it does not exceed the maximum authorized amount. This flexibility is important for several reasons:

1. **Dynamic Billing Needs** : Many services have varying costs depending on usage. For example, cloud services, utilities, or other pay-as-you-go models might generate different billing amounts each month. Allowing payments to be pulled for amounts less than the authorized maximum ensures that users are only charged for what they have used, without the need to authorize a different amount for each billing cycle.
2. **Credit Adjustments** : In scenarios where a user is given a credit (e.g., a refund, discount, or bonus), it is more efficient to apply this credit directly to reduce the amount pulled in the next subscription payment. This avoids the need to take the full authorized amount and then issue a separate credit back to the user. By pulling only the adjusted amount, the system simplifies the transaction process and reduces unnecessary operations, making the billing process smoother and more transparent.
3. **User Convenience and Trust** : Allowing for partial pulls under the maximum authorized amount enhances user trust by ensuring that they are only charged what is necessary. This avoids potential frustration or confusion that could arise from seeing multiple transactions (e.g., a full payment followed by a credit) on their account.

### A.3 Can the Receiver pull multiple transactions within a period?

No, the receiver cannot pull multiple transactions within the same subscription period. The subscription model is designed to allow only one transaction per defined period (e.g., monthly, weekly) as specified in the `SubscriptionSet` transaction.

Once a payment is pulled, the system updates the `NextPaymentTime` field, ensuring that no additional payments can be claimed until the next period begins. This safeguard prevents the possibility of multiple deductions from the user's account within the same billing cycle, thereby protecting the user from unauthorized or excessive withdrawals.

This mechanism ensures that the subscription operates predictably, aligning with the user’s expectations for regular, recurring payments and preventing potential abuse by the beneficiary.

### A.4 Can the user modify the subscription settings after it has been created?

Yes, we have updated the specification to allow for dual use of the `SubscriptionSet` transaction. The account owner will be able to update the amount and optional expiration time fields. To adjust the destination, dTag, frequency or start time, the account owner should cancel the subscription and create a new one.

### A.5 What prevents a user from signing up for a 12-month subscription and then cancelling it prematurely?

There is nothing within the subscription mechanism itself that prevents a user from cancelling a subscription at any time, even if it was intended for a longer period, such as 12 months. This is similar to how traditional direct debits work in many financial systems, where users can cancel payments at any time.

To mitigate the risks associated with premature cancellation, service providers should enforce their terms of service to handle such situations. The XRP Ledger subscription model provides the technical foundation for recurring payments but does not enforce contractual obligations between the user and the service provider.

### A.6 What happens if the user’s account cannot fulfil a subscription payment?

If the user’s account does not have sufficient funds to cover the subscription payment when a `SubscriptionClaim` transaction is submitted, the transaction will fail, and no funds will be transferred. The `NextPaymentTime` will remain unchanged, meaning the subscription will not reset until a successful payment is made.

In such cases, the service provider is in a similar position as they would be with a failed direct debit payment in traditional banking systems. They would need to rely on their own policies, such as retrying the payment at a later time or taking action based on the terms of service agreed upon with the user.

### A.7 Can the subscription be paused temporarily?

Currently, the subscription model does not include a specific "pause" feature. However, there are two ways to effectively pause a subscription:

1. **Cancel and Recreate** : The user can cancel the subscription using a `SubscriptionCancel` transaction and later recreate it with a `SubscriptionCreate` transaction when they wish to resume payments. This method gives the user full control over their subscriptions but requires them to manage the timing manually.
2. **Pause the Service with the Provider** : The user can also pause the service directly with the provider, leaving the subscription in place. In this case, the provider has two options:

   1. **Submit a 0-Value Claim** : The provider can submit a `SubscriptionClaim` transaction with a 0-value amount, which would be considered valid and would update the `NextPaymentTime` without transferring any funds. This allows the subscription to remain active while effectively pausing payments.
   2. **Partial Payment** : The provider could agree to a partial payment for the period (e.g., pausing the service for two weeks and submitting a claim for 50% of the maximum value). This allows the provider to reduce the payment amount based on the paused duration while still maintaining the subscription’s timing and validity.

      These options provide flexibility while ensuring that the subscription mechanism can accommodate temporary service pauses without requiring users to fully cancel their subscriptions.

### A.8 How is the subscription terminated?

A subscription can be terminated by the user at any time by submitting a `SubscriptionCancel` transaction. Once cancelled, no further payments can be claimed under that subscription, and the associated ledger entry will be removed. If the user wants to restart the subscription, a new `SubscriptionCreate` transaction must be submitted. This specification has been updated to also allow the destination (beneficiary) on the subscription to cancel the subscription too.

### A.9 Can multiple subscriptions be created for the same beneficiary?

Yes, a user can create multiple subscriptions for the same destination, each with different parameters such as amount, frequency, and start time. Each subscription operates independently, allowing for flexible payment arrangements, such as different services or products billed separately by the same beneficiary.

### A.10 What safeguards are in place to prevent unauthorized modifications to a subscription?

Subscriptions can be modified once they are created, but with very limited scope, only the amount and expiration time can be changed and this can only be claimed by the account owner.

`SubscriptionSet` must be signed by the account owner, ensuring that only the account owner or an authorized delegate can setup or modify a subscription, thereby preventing unauthorized changes.

### A.11 What considerations have been given to this being used by a bad actor to create network spam?

Nothing would prevent an account owner from setting up hundreds of subscriptions, but this is true of any transaction that generates an account object and is mitigated by the cost of the object reserve.

A bad actor can only claim a subscription, if they are defined as the destination address on the subscription and a claim can only be submitted once during a period; as described above this prevents the potential for spamming of micro transactions within a period. The only other transaction a bad actor can submit would be a cancel but this can only be performed on a subscription to which they are the beneficiary and can only be performed once.

We do not consider this proposal to be open to any new form of spam, but remain open to further discussions should anyone have concerns.
